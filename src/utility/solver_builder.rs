use std::ops::RangeInclusive;

use crate::utility::prelude::*;
use alloc::{boxed::Box, vec::Vec};

fn assert_shape(b: bool) -> Result<(), ndarray::ShapeError> {
    b.then_some(())
        .ok_or_else(|| ndarray::ShapeError::from_kind(ndarray::ErrorKind::IncompatibleShape))
}

type PoolFunc<'a> = Box<dyn Fn(usize, RangeInclusive<f64>, &Rng) -> f64 + 'a>;

/// Initial pool generating options.
///
/// Use [`SolverBuilder::init_pool()`] to set this option.
pub enum Pool<'a, F: ObjFunc> {
    /// A ready-made pool and its fitness values.
    Ready {
        /// Pool
        pool: Array2<f64>,
        /// Fitness values
        fitness: Vec<F::Fitness>,
    },
    /// Generate the pool uniformly with a filter function to check the
    /// validity.
    ///
    /// This filter function returns true if the design variables are valid.
    #[allow(clippy::type_complexity)]
    UniformBy(Box<dyn Fn(&[f64]) -> bool + 'a>),
    /// Generate the pool with a specific function.
    ///
    /// The function signature is `fn(s, min..max, &rng) -> value`
    /// + `s` is the index of the variable
    /// + `min..max` is the range of the variable
    /// + `rng` is the random number generator
    ///
    /// Two examples are [`uniform_pool()`] and [`gaussian_pool()`].
    ///
    /// ```
    /// use metaheuristics_nature::{gaussian_pool, Pool, Rga, Solver};
    /// # use metaheuristics_nature::tests::TestObj as MyFunc;
    ///
    /// let pool = Pool::Func(Box::new(gaussian_pool(&[0.; 4], &[1.; 4])));
    /// let s = Solver::build(Rga::default(), MyFunc::new())
    /// #   .task(|ctx| ctx.gen == 1)
    ///     .init_pool(pool)
    ///     .solve()
    ///     .unwrap();
    /// ```
    Func(PoolFunc<'a>),
}

/// Collect configuration and build the solver.
///
/// This type is created by [`Solver::build()`] method.
#[allow(clippy::type_complexity)]
#[must_use = "solver builder do nothing unless call the \"solve\" method"]
pub struct SolverBuilder<'a, F: ObjFunc> {
    func: F,
    pop_num: usize,
    seed: SeedOption,
    regen: bool,
    algorithm: Box<dyn Algorithm<F>>,
    pool: Pool<'a, F>,
    task: Box<dyn Fn(&Ctx<F>) -> bool + Send + 'a>,
    callback: Box<dyn FnMut(&mut Ctx<F>) + Send + 'a>,
}

impl<'a, F: ObjFunc> SolverBuilder<'a, F> {
    impl_builders! {
        /// Population number.
        ///
        /// # Default
        ///
        /// If not changed by the algorithm setting, the default number is 200.
        fn pop_num(usize)

        /// Regenerate the invalid individuals per generation. May spent more time.
        ///
        /// # Default
        ///
        /// By default, this function is disabled.
        fn regen(bool)
    }

    /// Set the random seed to get a determined result.
    ///
    /// # Default
    ///
    /// By default, the random seed is auto-decided.
    pub fn seed(self, seed: impl Into<SeedOption>) -> Self {
        Self { seed: seed.into(), ..self }
    }

    /// Initialize the pool with the pool option.
    ///
    /// # Default
    ///
    /// By default, the pool is generated by the uniform distribution
    /// [`uniform_pool()`].
    pub fn init_pool(self, pool: Pool<'a, F>) -> Self {
        Self { pool, ..self }
    }

    /// Termination condition.
    ///
    /// The task function will be check each iteration, breaks if the return is
    /// true.
    ///
    /// ```
    /// use metaheuristics_nature::{Rga, Solver};
    /// # use metaheuristics_nature::tests::TestObj as MyFunc;
    ///
    /// let s = Solver::build(Rga::default(), MyFunc::new())
    ///     .task(|ctx| ctx.gen == 20)
    ///     .solve()
    ///     .unwrap();
    /// ```
    ///
    /// # Default
    ///
    /// By default, the algorithm will iterate 200 generation.
    pub fn task<'b, C>(self, task: C) -> SolverBuilder<'b, F>
    where
        'a: 'b,
        C: Fn(&Ctx<F>) -> bool + Send + 'b,
    {
        SolverBuilder { task: Box::new(task), ..self }
    }

    /// Set callback function.
    ///
    /// Callback function allows to change an outer mutable variable in each
    /// iteration.
    ///
    /// ```
    /// use metaheuristics_nature::{Rga, Solver};
    /// # use metaheuristics_nature::tests::TestObj as MyFunc;
    ///
    /// let mut gen = 0;
    /// let s = Solver::build(Rga::default(), MyFunc::new())
    /// #   .task(|ctx| ctx.gen == 1)
    ///     .callback(|ctx| gen = ctx.gen)
    ///     .solve()
    ///     .unwrap();
    /// ```
    ///
    /// # Default
    ///
    /// By default, this function does nothing.
    pub fn callback<'b, C>(self, callback: C) -> SolverBuilder<'b, F>
    where
        'a: 'b,
        C: FnMut(&mut Ctx<F>) + Send + 'b,
    {
        SolverBuilder { callback: Box::new(callback), ..self }
    }

    /// Create the task and run the algorithm, which may takes a lot of time.
    ///
    /// Generation `ctx.gen` is start from 1, initialized at 0.
    ///
    /// # Error
    ///
    /// This function will be `Ok` and returns result when the `ctx.pool` and
    /// `ctx.fitness` initialized successfully; `Err` when the boundary check
    /// fails.
    pub fn solve(self) -> Result<Solver<F>, ndarray::ShapeError> {
        let Self {
            func,
            pop_num,
            seed,
            regen,
            mut algorithm,
            pool,
            task,
            mut callback,
        } = self;
        assert_shape(func.bound().iter().all(|[lb, ub]| lb <= ub))?;
        let mut ctx = Ctx::new(func, pop_num);
        let rng = Rng::new(seed);
        match pool {
            Pool::Ready { pool, fitness } => {
                assert_shape(pool.shape() == ctx.pool_size())?;
                ctx.pool = pool;
                ctx.pool_f = fitness;
                ctx.find_best_force();
            }
            Pool::UniformBy(filter) => {
                let mut pool = Vec::with_capacity(ctx.pop_num());
                let rand_f = uniform_pool();
                let pop_num = ctx.pop_num();
                while pool.len() < pop_num {
                    let x = (0..ctx.dim())
                        .map(|s| rand_f(s, ctx.func.bound_range(s), &rng))
                        .collect::<Vec<_>>();
                    if filter(&x) {
                        pool.extend(x);
                    }
                }
                ctx.init_pop(Array2::from_shape_vec(ctx.pool_size(), pool).unwrap());
            }
            Pool::Func(f) => ctx.init_pop(Array2::from_shape_fn(ctx.pool_size(), |(_, s)| {
                ctx.clamp(s, f(s, ctx.func.bound_range(s), &rng))
            })),
        }
        algorithm.init(&mut ctx, &rng);
        loop {
            callback(&mut ctx);
            if task(&ctx) {
                break;
            }
            ctx.gen += 1;
            algorithm.generation(&mut ctx, &rng);
            if regen {
                ctx.pool
                    .axis_iter_mut(Axis(0))
                    .zip(ctx.pool_f.iter_mut())
                    .filter(|(_, f)| f.partial_cmp(f).is_none())
                    .for_each(|(mut xs, f)| {
                        xs.iter_mut()
                            .enumerate()
                            .for_each(|(s, x)| *x = rng.range(ctx.func.bound_range(s)));
                        *f = ctx.func.fitness(xs.as_slice().unwrap());
                    });
            }
        }
        Ok(Solver::new(ctx, rng.seed()))
    }
}

impl<F: ObjFunc> Solver<F> {
    /// Start to build a solver. Take a setting and setup the configurations.
    ///
    /// Please check [`SolverBuilder`] type, it will help you choose your
    /// configuration.
    ///
    /// If all things are well-setup, call [`SolverBuilder::solve()`].
    ///
    /// The default value of each option can be found in their document.
    pub fn build<S>(setting: S, func: F) -> SolverBuilder<'static, F>
    where
        S: Setting,
    {
        SolverBuilder {
            func,
            pop_num: S::default_pop(),
            seed: SeedOption::None,
            regen: false,
            algorithm: Box::new(setting.algorithm()),
            pool: Pool::Func(Box::new(uniform_pool())),
            task: Box::new(|ctx| ctx.gen >= 200),
            callback: Box::new(|_| ()),
        }
    }
}

/// A function generates a uniform pool.
///
/// See also [`gaussian_pool()`], [`Pool::Func`],
/// [`SolverBuilder::init_pool()`].
pub fn uniform_pool() -> PoolFunc<'static> {
    Box::new(move |_, range, rng| rng.range(range))
}

/// A function generates a Gaussian pool.
///
/// Where `mean` is the mean value, `std` is the standard deviation.
///
/// See also [`uniform_pool()`], [`Pool::Func`], [`SolverBuilder::init_pool()`].
///
/// # Panics
///
/// Panic when the lengths of `mean` and `std` are not the same.
pub fn gaussian_pool<'a>(mean: &'a [f64], std: &'a [f64]) -> PoolFunc<'a> {
    assert_eq!(mean.len(), std.len());
    Box::new(move |s, _, rng| rng.normal(mean[s], std[s]))
}
